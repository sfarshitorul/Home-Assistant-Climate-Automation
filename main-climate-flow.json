[
    {
        "disabled": false,
        "env": [
        ],
        "id": "6e4b058d9d8e0a83",
        "info": "",
        "label": "Main Climate Flow",
        "type": "tab"
    },
    {
        "crontab": "",
        "id": "0280047982c0a52b",
        "name": "Init + every 60s",
        "once": true,
        "onceDelay": "1",
        "props": [
        ],
        "repeat": "",
        "topic": "",
        "type": "inject",
        "wires": [
            [
                "21547463e3d44df3"
            ]
        ],
        "x": 140,
        "y": 400,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "active": true,
        "complete": "payload",
        "console": false,
        "id": "929a46e030f17a28",
        "name": "unified snapshot",
        "statusType": "auto",
        "statusVal": "",
        "targetType": "msg",
        "tosidebar": true,
        "tostatus": false,
        "type": "debug",
        "wires": [
        ],
        "x": 720,
        "y": 680,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "finalize": "",
        "func": "// Get HA state cache from global context\nlet states = [];\nlet unified = null;\n\n//If you need to add a new entity it needs to be added \n//inside both process... functions\n\n\n// Helper: safely get numeric state\nfunction num(entity_id) {\n    const s = states[entity_id];\n    if (!s) {\n        node.warn(`Missing entity: ${entity_id}`);\n        return null;\n    }\n    const n = parseFloat(s.state);\n    return isNaN(n) ? null : n;\n}\n\n// Helper: safely get boolean state (on/off)\nfunction bool(entity_id) {\n    const s = states[entity_id];\n    if (!s) {\n        node.warn(`Missing entity: ${entity_id}`);\n        return null;\n    }\n    const v = s.state;\n    return v === 'on' || v === true;\n}\n\n// ----- Build unified object -----\nfunction processCurrentStates() {\n    const ha = global.get('homeassistant');\n    if (!ha || !ha.homeAssistant || !ha.homeAssistant.states) {\n        node.warn(\"Home Assistant state cache not ready in global context\");\n        return null;\n    }\n\n    states = ha.homeAssistant.states;\n\n    unified = {\n        summer_mode: bool('input_boolean.summer_mode'),\n        we_are_away: bool('input_boolean.we_are_away'),\n        we_are_away_temp: num('input_number.away_temp'),\n        heat_needed: null,\n        changes_detected: false,\n\n\n        rooms: {\n            living: {\n                current_temp:  num('sensor.living_temp_temperature'),\n                window_opened: bool('binary_sensor.living_window_contact'),\n\n                morning_temp:  num('input_number.living_morning_temp'),\n                day_temp:      num('input_number.living_day_temp'),\n                evening_temp:  num('input_number.living_evening_temp'),\n                night_temp:    num('input_number.living_night_temp'),\n                delta_temp:    num('input_number.living_delta_temp'),\n\n                morning_start: num('input_number.living_morning_start'),\n                day_start:     num('input_number.living_day_start'),\n                evening_start: num('input_number.living_evening_start'),\n                night_start:   num('input_number.living_night_start'),\n                \n                targetTemp: null,\n                would_start_soon: false,\n                trv_temp: null,\n                heater_needed: false\n            },\n\n            bedroom: {\n                current_temp:  num('sensor.bedroom_temp_temperature'),\n                window_opened: bool('binary_sensor.balcony_window_contact'),\n\n                morning_temp:  num('input_number.bedroom_morning_temp'),\n                day_temp:      num('input_number.bedroom_day_temp'),\n                evening_temp:  num('input_number.bedroom_evening_temp'),\n                night_temp:    num('input_number.bedroom_night_temp'),\n                delta_temp:    num('input_number.bedroom_delta_temp'),\n\n                morning_start: num('input_number.bedroom_morning_start'),\n                day_start:     num('input_number.bedroom_day_start'),\n                evening_start: num('input_number.bedroom_evening_start'),\n                night_start:   num('input_number.bedroom_night_start'),\n                \n                targetTemp: null,\n                would_start_soon: false,\n                trv_temp: null,\n                heater_needed: false\n            },\n\n            bbls: {\n                current_temp:  num('sensor.bbls_temp_temperature'),\n                window_opened: bool('binary_sensor.bbls_window_contact'),\n\n                morning_temp:  num('input_number.bbls_morning_temp'),\n                day_temp:      num('input_number.bbls_day_temp'),\n                evening_temp:  num('input_number.bbls_evening_temp'),\n                night_temp:    num('input_number.bbls_night_temp'),\n                delta_temp:    num('input_number.bbls_delta_temp'),\n\n                morning_start: num('input_number.bbls_morning_start'),\n                day_start:     num('input_number.bbls_day_start'),\n                evening_start: num('input_number.bbls_evening_start'),\n                night_start:   num('input_number.bbls_night_start'),\n\n                targetTemp: null,\n                would_start_soon: false,\n                trv_temp: null,\n                heater_needed: false\n            },\n\n            balcony: {\n                current_temp:  num('sensor.balcony_temp_temperature'),\n                window_opened: bool('binary_sensor.balcony_window_contact'),\n                radiator_override: bool('input_boolean.radiator_manual_override'),\n\n                morning_temp:  num('input_number.balcony_morning_temp'),\n                day_temp:      num('input_number.balcony_day_temp'),\n                evening_temp:  num('input_number.balcony_evening_temp'),\n                night_temp:    num('input_number.balcony_night_temp'),\n                delta_temp:    num('input_number.balcony_delta_temp'),\n\n                targetTemp: null,\n                trv_temp: null,\n                heater_needed: false\n            },\n\n            kitchen: {\n                window_opened: bool('binary_sensor.kitchen_window_contact'),\n\n                morning_temp:  num('input_number.kitchen_morning_temp'),\n                day_temp:      num('input_number.kitchen_day_temp'),\n                evening_temp:  num('input_number.kitchen_evening_temp'),\n                night_temp:    num('input_number.kitchen_night_temp'),\n\n                targetTemp: null,\n                trv_temp: null,\n                heater_needed: false\n            }\n        }\n    };\n\n    // Store in flow context so other flows can reuse it\n    flow.set('unified_entities', unified); \n    return unified;\n}\n\n// ----- If event triggered by watched entity - build unified object -------\nfunction processCurrentEvent() {\n    const watchedEvents = new Set([\n        \"input_boolean.summer_mode\",\n        \"input_boolean.we_are_away\",\n        \"input_number.away_temp\",\n\n        \"sensor.living_temp_temperature\",\n        \"binary_sensor.living_window_contact\",\n        \"input_number.living_morning_temp\",\n        \"input_number.living_day_temp\",\n        \"input_number.living_evening_temp\",\n        \"input_number.living_night_temp\",\n        \"input_number.living_delta_temp\",\n        \"input_number.living_morning_start\",\n        \"input_number.living_day_start\",\n        \"input_number.living_evening_start\",\n        \"input_number.living_night_start\",\n\n\n        \"sensor.bedroom_temp_temperature\",\n        \"binary_sensor.balcony_window_contact\",\n        \"input_number.bedroom_morning_temp\",\n        \"input_number.bedroom_day_temp\",\n        \"input_number.bedroom_evening_temp\",\n        \"input_number.bedroom_night_temp\",\n        \"input_number.bedroom_delta_temp\",\n        \"input_number.bedroom_morning_start\",\n        \"input_number.bedroom_day_start\",\n        \"input_number.bedroom_evening_start\",\n        \"input_number.bedroom_night_start\",\n\n\n        \"sensor.bbls_temp_temperature\",\n        \"binary_sensor.bbls_window_contact\",\n        \"input_number.bbls_morning_temp\",\n        \"input_number.bbls_day_temp\",\n        \"input_number.bbls_evening_temp\",\n        \"input_number.bbls_night_temp\",\n        \"input_number.bbls_delta_temp\",\n        \"input_number.bbls_morning_start\",\n        \"input_number.bbls_day_start\",\n        \"input_number.bbls_evening_start\",\n        \"input_number.bbls_night_start\",\n\n\n        \"sensor.balcony_temp_temperature\",\n        \"binary_sensor.balcony_window_contact\",\n        \"input_number.balcony_morning_temp\",\n        \"input_number.balcony_day_temp\",\n        \"input_number.balcony_evening_temp\",\n        \"input_number.balcony_night_temp\",\n        \"input_number.balcony_delta_temp\",\n        \"input_boolean.radiator_manual_override\",\n\n\n        \"input_number.kitchen_morning_temp\",\n        \"input_number.kitchen_day_temp\",\n        \"input_number.kitchen_evening_temp\",\n        \"input_number.kitchen_night_temp\",\n        \"binary_sensor.kitchen_window_contact\"\n    ]);\n\n    // events: all puts the event in msg.payload\n    const ev = msg.payload;  \n    if (!ev || ev.event_type !== \"state_changed\") {\n        return null;\n    }\n\n    const data = ev.event || {};\n    const entity_id = data.entity_id;\n\n    if (!entity_id || !watchedEvents.has(entity_id)) {\n        return null; // not an entity we care about\n    }\n    \n    unified = processCurrentStates();\n    return unified;\n}\n\nunified = processCurrentEvent(); \n\n//We shouldn't do anything if there is no data \n// or if Summer Mode is active\nif (unified != null && !unified.summer_mode) {\n    \n    // Also output it\n    msg.payload = unified;\n    return msg;\n}\n",
        "id": "21547463e3d44df3",
        "initialize": "",
        "libs": [
        ],
        "name": "Get States and Build Unified Object",
        "noerr": 0,
        "outputs": 1,
        "timeout": 0,
        "type": "function",
        "wires": [
            [
                "55b44918d02a3df9"
            ]
        ],
        "x": 440,
        "y": 480,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "eventData": "",
        "eventType": "state_changed",
        "exposeAsEntityConfig": "",
        "id": "bef5a717e789f4a6",
        "name": "Listen to all events",
        "outputProperties": [
            {
                "property": "payload",
                "propertyType": "msg",
                "value": "",
                "valueType": "eventData"
            },
            {
                "property": "topic",
                "propertyType": "msg",
                "value": "$outputData(\"eventData\").event_type",
                "valueType": "jsonata"
            }
        ],
        "server": "bb9894b2.8b5ad8",
        "type": "server-events",
        "version": 3,
        "waitForRunning": true,
        "wires": [
            [
                "21547463e3d44df3"
            ]
        ],
        "x": 130,
        "y": 480,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "finalize": "",
        "func": "const isAway = msg.payload.we_are_away;\nconst targetTemp = parseFloat(msg.payload.we_are_away_temp); //Using away temp as initial temp for the system\n\n\n// Helper to safely read nested paths like \"rooms.living.trv_temp\"\nfunction get(obj, path) {\n    return path.split('.').reduce((o, k) => (o && k in o ? o[k] : undefined), obj);\n}\n\n\nfunction Apply_Balcony_Logic() {\n    //If we override the logic we should return the msg obj untouched\n    const balconyOverride = msg.payload.rooms.balcony.radiator_override;\n    if (balconyOverride) return msg;\n\n    const windowOpened = msg.payload.rooms.balcony.window_opened;\n    if (windowOpened) {\n        msg.payload.rooms.balcony.heater_needed = false;\n        return msg;\n    }\n\n    const weekday = [\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"];\n    const d = new Date();\n    let day = weekday[d.getDay()];\n    switch (day) {\n        case \"Sunday\":\n        case \"Saturday\":\n            return;\n            \n    }\n\n    let targetT = parseFloat(msg.payload.rooms.balcony.day_temp);\n\n    if (isAway) {\n        targetT = targetTemp;\n    }\n    else {\n        targetT = parseFloat(msg.payload.rooms.balcony.day_temp);\n        \n        let hour = new Date().getHours();\n        let period = 'night';\n\n        if (hour >= 7 && hour < 9) {\n            period = 'morning';\n        } else if (hour >= 9 && hour < 17) {\n            period = 'day';\n        } else if (hour >= 17 && hour < 21) {\n            period = 'evening';\n        } else {\n            period = 'night';\n        }\n\n\n        switch(period){\n            case \"morning\":\n                targetT = parseFloat(msg.payload.rooms.balcony.morning_temp);\n                break;\n            case \"day\":\n                targetT = parseFloat(msg.payload.rooms.balcony.day_temp);\n                break;\n            case \"evening\":\n                targetT = parseFloat(msg.payload.rooms.balcony.evening_temp);\n                break;\n            case \"night\":\n                targetT = parseFloat(msg.payload.rooms.balcony.night_temp);\n                break;\n            default:\n                targetT = parseFloat(msg.payload.rooms.balcony.day_temp);\n                break;\n        }\n    }\n\n    msg.payload.rooms.balcony.targetTemp = targetT;\n    \n    const deltaTemp = parseFloat(msg.payload.rooms.balcony.delta_temp);\n    const currentTemp = parseFloat(msg.payload.rooms.balcony.current_temp);\n    const lowerLimit = targetT - deltaTemp;\n    const upperLimit = targetT + deltaTemp;\n\n    if (currentTemp <= lowerLimit) {\n        // Below lower limit — heating ON\n        msg.payload.rooms.balcony.heater_needed = true;\n    }\n    else if (currentTemp >= upperLimit) {\n        // Above upper limit — heating OFF\n        msg.payload.rooms.balcony.heater_needed = false;\n    }\n    else {\n        // In between — maintain current state or continue heating if already on\n        msg.payload.rooms.balcony.heater_needed = true;\n    }\n}\n\nfunction Apply_Kitchen_Logic() {\n    //Kitchen is not taken into account when starting the heater\n    let hour = new Date().getHours();\n    let period = 'night';\n\n    if (hour >= 6 && hour < 9) {\n        period = 'morning';\n    } else if (hour >= 9 && hour < 17) {\n        period = 'day';\n    } else if (hour >= 17 && hour < 21) {\n        period = 'evening';\n    } else {\n        period = 'night';\n    }\n\n    switch(period){\n        case \"morning\":\n            msg.payload.rooms.kitchen.trv_temp = 35;\n            msg.payload.rooms.kitchen.heater_needed = true;\n            break;\n        case \"day\":\n            msg.payload.rooms.kitchen.trv_temp = 35;\n            msg.payload.rooms.kitchen.heater_needed = true;\n            break;\n        case \"evening\":\n            msg.payload.rooms.kitchen.trv_temp = 5;\n            msg.payload.rooms.kitchen.heater_needed = false;\n            break;\n        case \"night\":\n            msg.payload.rooms.kitchen.trv_temp = 5;\n            msg.payload.rooms.kitchen.heater_needed = false;\n            break;\n        default:\n            msg.payload.rooms.kitchen.trv_temp = 35;\n            msg.payload.rooms.kitchen.heater_needed = true;\n            break;\n    }\n}\n\nfunction Apply_Bbls_Logic() {\n    const windowOpened = msg.payload.rooms.bbls.window_opened;\n    if (windowOpened) {\n        msg.payload.rooms.bbls.heater_needed = false;\n        msg.payload.rooms.bbls.trv_temp = 5;\n        return msg;\n    }\n\n\n    let targetT = msg.payload.rooms.bbls.day_temp;\n\n    if (isAway) {\n        targetT = targetTemp;\n    }\n    else {\n        targetT = parseFloat(msg.payload.rooms.bbls.day_temp);\n        \n        let hour = new Date().getHours();\n        let period = 'night';\n        \n        if (hour >= msg.payload.rooms.bbls.morning_start && hour < msg.payload.rooms.bbls.day_start) {\n            period = 'morning';\n        } else if (hour >= msg.payload.rooms.bbls.day_start && hour < msg.payload.rooms.bbls.evening_start) {\n            period = 'day';\n        } else if (hour >= msg.payload.rooms.bbls.evening_start && hour < msg.payload.rooms.bbls.night_start) {\n            period = 'evening';\n        } else {\n            period = 'night';\n        }\n\n        switch(period){\n            case \"morning\":\n                targetT = parseFloat(msg.payload.rooms.bbls.morning_temp);\n                break;\n            case \"day\":\n                targetT = parseFloat(msg.payload.rooms.bbls.day_temp);\n                break;\n            case \"evening\":\n                targetT = parseFloat(msg.payload.rooms.bbls.evening_temp);\n                break;\n            case \"night\":\n                targetT = parseFloat(msg.payload.rooms.bbls.night_temp);\n                break;\n            default:\n                targetT = parseFloat(msg.payload.rooms.bbls.day_temp);\n                break;\n        }\n    }\n\n    const deltaTemp = parseFloat(msg.payload.rooms.bbls.delta_temp);\n    const currentTemp = parseFloat(msg.payload.rooms.bbls.current_temp);\n\n    const upperLimit = targetT + deltaTemp;\n    const lowerLimit = targetT - deltaTemp;\n    const lowerLimitSoon = targetT - deltaTemp/2;\n\n    msg.payload.rooms.bbls.targetTemp = targetT;\n\n    //Check temp and set TRV temp and set the heater_on variable\n    if (currentTemp <= lowerLimit) {\n        // Below lower limit — heating ON\n        msg.payload.rooms.bbls.trv_temp = 35;\n        msg.payload.rooms.bbls.heater_needed = true;\n    }\n    else if (currentTemp >= upperLimit) {\n        // Above upper limit — heating OFF\n        msg.payload.rooms.bbls.trv_temp = 5;\n        msg.payload.rooms.bbls.heater_needed = false;\n    }\n    else {\n        // In between — maintain current state or continue heating if already on\n        msg.payload.rooms.bbls.trv_temp = 35;\n        msg.payload.rooms.bbls.heater_needed = true;\n    }\n\n    if (currentTemp <= lowerLimitSoon) {\n        // Below lower limit — heating ON\n        msg.payload.rooms.bbls.trv_temp = 35;\n        msg.payload.rooms.bbls.would_start_soon = true;\n    }\n}\n\nfunction Apply_Bedroom_Logic() {\n    const windowOpened = msg.payload.rooms.bedroom.window_opened;\n    if (windowOpened) {\n        msg.payload.rooms.bedroom.heater_needed = false;\n        msg.payload.rooms.bedroom.trv_temp = 5;\n        return msg;\n    }\n\n    let targetT = msg.payload.rooms.bedroom.day_temp;\n\n    if (isAway) {\n        targetT = targetTemp;\n    }\n    else {\n        targetT = parseFloat(msg.payload.rooms.bedroom.day_temp);\n        \n        let hour = new Date().getHours();\n        let period = 'night';\n        \n        if (hour >= msg.payload.rooms.bedroom.morning_start && hour < msg.payload.rooms.bedroom.day_start) {\n            period = 'morning';\n        } else if (hour >= msg.payload.rooms.bedroom.day_start && hour < msg.payload.rooms.bedroom.evening_start) {\n            period = 'day';\n        } else if (hour >= msg.payload.rooms.bedroom.evening_start && hour < msg.payload.rooms.bedroom.night_start) {\n            period = 'evening';\n        } else {\n            period = 'night';\n        }\n\n        switch(period){\n            case \"morning\":\n                targetT = parseFloat(msg.payload.rooms.bedroom.morning_temp);\n                break;\n            case \"day\":\n                targetT = parseFloat(msg.payload.rooms.bedroom.day_temp);\n                break;\n            case \"evening\":\n                targetT = parseFloat(msg.payload.rooms.bedroom.evening_temp);\n                break;\n            case \"night\":\n                targetT = parseFloat(msg.payload.rooms.bedroom.night_temp);\n                break;\n            default:\n                targetT = parseFloat(msg.payload.rooms.bedroom.day_temp);\n                break;\n        }\n    }\n\n    const deltaTemp = parseFloat(msg.payload.rooms.bedroom.delta_temp);\n    const currentTemp = parseFloat(msg.payload.rooms.bedroom.current_temp);\n\n    const upperLimit = targetT + deltaTemp;\n    const lowerLimit = targetT - deltaTemp;\n    const lowerLimitSoon = targetT - deltaTemp/2;\n\n    msg.payload.rooms.bedroom.targetTemp = targetT;\n\n    //Check temp and set TRV temp and set the heater_on variable\n    if (currentTemp <= lowerLimit) {\n        // Below lower limit — heating ON\n        msg.payload.rooms.bedroom.trv_temp = 35;\n        msg.payload.rooms.bedroom.heater_needed = true;\n    }\n    else if (currentTemp >= upperLimit) {\n        // Above upper limit — heating OFF\n        msg.payload.rooms.bedroom.trv_temp = 5;\n        msg.payload.rooms.bedroom.heater_needed = false;\n    }\n    else {\n        // In between — maintain current state or continue heating if already on\n        msg.payload.rooms.bedroom.trv_temp = 35;\n        msg.payload.rooms.bedroom.heater_needed = true;\n    }\n\n    if (currentTemp <= lowerLimitSoon) {\n        // Below lower limit — heating ON\n        msg.payload.rooms.bedroom.trv_temp = 35;\n        msg.payload.rooms.bedroom.would_start_soon = true;\n    }\n}\n\nfunction Apply_Living_Logic() {\n    const windowOpened = msg.payload.rooms.living.window_opened;\n    if (windowOpened) {\n        msg.payload.rooms.living.heater_needed = false;\n        msg.payload.rooms.living.trv_temp = 5;\n        return msg;\n    }\n\n    let targetT = msg.payload.rooms.living.day_temp;\n\n    if (isAway) {\n        targetT = targetTemp;\n    }\n    else {\n        targetT = parseFloat(msg.payload.rooms.living.day_temp);\n        \n        let hour = new Date().getHours();\n        let period = 'night';\n        \n        if (hour >= msg.payload.rooms.living.morning_start && hour < msg.payload.rooms.living.day_start) {\n            period = 'morning';\n        } else if (hour >= msg.payload.rooms.living.day_start && hour < msg.payload.rooms.living.evening_start) {\n            period = 'day';\n        } else if (hour >= msg.payload.rooms.living.evening_start && hour < msg.payload.rooms.living.night_start) {\n            period = 'evening';\n        } else {\n            period = 'night';\n        }\n\n        switch(period){\n            case \"morning\":\n                targetT = parseFloat(msg.payload.rooms.living.morning_temp);\n                break;\n            case \"day\":\n                targetT = parseFloat(msg.payload.rooms.living.day_temp);\n                break;\n            case \"evening\":\n                targetT = parseFloat(msg.payload.rooms.living.evening_temp);\n                break;\n            case \"night\":\n                targetT = parseFloat(msg.payload.rooms.living.night_temp);\n                break;\n            default:\n                targetT = parseFloat(msg.payload.rooms.living.day_temp);\n                break;\n        }\n    }\n\n    const deltaTemp = parseFloat(msg.payload.rooms.living.delta_temp);\n    const currentTemp = parseFloat(msg.payload.rooms.living.current_temp);\n\n    const upperLimit = targetT + deltaTemp;\n    const lowerLimit = targetT - deltaTemp;\n    const lowerLimitSoon = targetT - deltaTemp/2;\n\n    msg.payload.rooms.living.targetTemp = targetT;\n\n    //Check temp and set TRV temp and set the heater_on variable\n    if (currentTemp <= lowerLimit) {\n        // Below lower limit — heating ON\n        msg.payload.rooms.living.trv_temp = 35;\n        msg.payload.rooms.living.heater_needed = true;\n    }\n    else if (currentTemp >= upperLimit) {\n        // Above upper limit — heating OFF\n        msg.payload.rooms.living.trv_temp = 5;\n        msg.payload.rooms.living.heater_needed = false;\n    }\n    else {\n        // In between — maintain current state or continue heating if already on\n        msg.payload.rooms.living.trv_temp = 35;\n        msg.payload.rooms.living.heater_needed = true;\n    }\n\n    if (currentTemp <= lowerLimitSoon) {\n        // Below lower limit — heating ON\n        msg.payload.rooms.living.trv_temp = 35;\n        msg.payload.rooms.living.would_start_soon = true;\n    }\n}\n\nfunction Check_If_Heat_Needed() {\n    let heat_needed = false;\n\n    //If either condition is true we need to start the heating\n    if(msg.payload.rooms.living.heater_needed === true\n    || msg.payload.rooms.bedroom.heater_needed === true\n    || msg.payload.rooms.bbls.heater_needed === true\n    ) {\n        heat_needed = true;  \n    }\n\n    //If a room would request hest soon we should start it \n    // if other room already made the heating request\n\n\n    //Heat required - process rooms that are close to needing heat\n    if (heat_needed) {\n        //Living did not request heat but would request soon\n        if (!msg.payload.rooms.living.heater_needed) {\n            if (msg.payload.rooms.living.would_start_soon)\n                msg.payload.rooms.living.heater_needed = true;\n        }\n\n        //Bedroom did not request heat but would request soon\n        if (!msg.payload.rooms.bedroom.heater_needed) {\n            if (msg.payload.rooms.bedroom.would_start_soon)\n                msg.payload.rooms.bedroom.heater_needed = true;\n        }\n\n        //Bbls did not request heat but would request soon\n        if (!msg.payload.rooms.bbls.heater_needed) {\n            if (msg.payload.rooms.bbls.would_start_soon)\n                msg.payload.rooms.bbls.heater_needed = true;\n        }\n    }\n\n    msg.payload.heat_needed = heat_needed;\n}\n\nfunction Check_If_Actions_Needed() {\n    // The unified object from your question\n    const current = msg.payload;\n\n    // Deep-clone so later nodes don't mutate what we store in context\n    const curr = JSON.parse(JSON.stringify(current));\n\n    // First message ever: just store and don't trigger\n    const prev = flow.get('unified_prev') || null;\n    if (!prev)\n    {\n        flow.set('unified_prev', curr);\n        return;\n    }\n\n    // List of fields you actually care about for triggering\n    // Add/remove as needed\n    const watched = [\n        'summer_mode',\n        'we_are_away',\n        'we_are_away_temp',\n        'heat_needed',\n\n        'rooms.living.heater_needed',\n        'rooms.bedroom.heater_needed',\n        'rooms.bbls.heater_needed',\n        'rooms.balcony.heater_needed',\n        'rooms.kitchen.heater_needed'\n    ];\n\n    let changed = {};\n\n    for (const path of watched) {\n        const oldVal = get(prev, path);\n        const newVal = get(curr, path);\n\n        // Normal strict comparison\n        if (oldVal === newVal) continue;\n    \n        // Something actually changed here\n        changed[path] = { old: oldVal, new: newVal };\n    }\n\n    // Update stored snapshot\n    flow.set('unified_prev', curr);\n\n    // If nothing changed in watched fields, stop here\n    if (Object.keys(changed).length === 0) {\n        msg.payload.changes_detected = false;\n    } else {\n        msg.payload.changes_detected = true;\n    }\n}\n\n\nApply_Balcony_Logic();\nApply_Kitchen_Logic();\n\n//These 3 rooms are similar, but there might be different\nApply_Bbls_Logic();\nApply_Bedroom_Logic();\nApply_Living_Logic();\n\nCheck_If_Heat_Needed();\n\nCheck_If_Actions_Needed();\n\n//If we have changes we need to return the msg object and advance the flow\nif (msg.payload.changes_detected)\n    return msg;\n\n//stop the current flow\nreturn null;",
        "id": "55b44918d02a3df9",
        "initialize": "",
        "libs": [
        ],
        "name": "Rooms Logic",
        "noerr": 0,
        "outputs": 1,
        "timeout": 0,
        "type": "function",
        "wires": [
            [
                "3515425a56bb2e1f",
                "840fcbdda2c74808",
                "929a46e030f17a28",
                "73a4b241abf41aa6",
                "255ebb28ad0a8cbb",
                "92a2f9ee979f8371",
                "b611bd668b366811",
                "344efd0e6c1bb913",
                "6eb622bb76a3546a",
                "d8f1651173e7a55b"
            ]
        ],
        "x": 710,
        "y": 480,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "climate.set_temperature",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{ \"temperature\": msg.payload.rooms.kitchen.trv_temp }",
        "dataType": "jsonata",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "climate",
        "entityId": [
            "climate.kitchen_trv"
        ],
        "floorId": [
        ],
        "id": "3515425a56bb2e1f",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Set Kitchen TRV Temp",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "set_temperature",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1000,
        "y": 20,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "checkall": "false",
        "id": "840fcbdda2c74808",
        "name": "Heat Req By Balcony",
        "outputs": 2,
        "property": "payload.rooms.balcony.heater_needed",
        "propertyType": "msg",
        "repair": false,
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "type": "switch",
        "wires": [
            [
                "53b8b6f7bca3d2a7",
                "4f43fbea2f916cf8"
            ],
            [
                "3a3a2a117bb6bc7e",
                "068a589d5bedeba0"
            ]
        ],
        "x": 1000,
        "y": 180,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "input_boolean.turn_on",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "input_boolean",
        "entityId": [
            "input_boolean.balcony_heater_needed"
        ],
        "floorId": [
        ],
        "id": "53b8b6f7bca3d2a7",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Enable Heat Req By Balcony",
        "outputProperties": [
            {
                "property": "payload",
                "propertyType": "msg",
                "value": "true",
                "valueType": "bool"
            },
            {
                "property": "topic",
                "propertyType": "msg",
                "value": "balcony_heater_needed",
                "valueType": "str"
            }
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_on",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1320,
        "y": 140,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "input_boolean.turn_off",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "input_boolean",
        "entityId": [
            "input_boolean.balcony_heater_needed"
        ],
        "floorId": [
        ],
        "id": "3a3a2a117bb6bc7e",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Disable Heat Req By Balcony",
        "outputProperties": [
            {
                "property": "payload",
                "propertyType": "msg",
                "value": "false",
                "valueType": "bool"
            },
            {
                "property": "topic",
                "propertyType": "msg",
                "value": "balcony_heater_needed",
                "valueType": "str"
            }
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_off",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1330,
        "y": 200,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "switch.turn_on",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "switch",
        "entityId": [
            "switch.balcony_radiator"
        ],
        "floorId": [
        ],
        "id": "4f43fbea2f916cf8",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Radiator Turn On ",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_on",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1290,
        "y": 80,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "switch.turn_off",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "switch",
        "entityId": [
            "switch.balcony_radiator"
        ],
        "floorId": [
        ],
        "id": "068a589d5bedeba0",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Radiator Turn Off",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_off",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1290,
        "y": 260,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "climate.set_temperature",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{ \"temperature\": msg.payload.rooms.living.trv_temp }",
        "dataType": "jsonata",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "climate",
        "entityId": [
            "climate.living_trv"
        ],
        "floorId": [
        ],
        "id": "255ebb28ad0a8cbb",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Set Living TRV Temp",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "set_temperature",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1000,
        "y": 440,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "climate.set_temperature",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{ \"temperature\": msg.payload.rooms.bedroom.trv_temp }",
        "dataType": "jsonata",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "climate",
        "entityId": [
            "climate.bedroom_trv"
        ],
        "floorId": [
        ],
        "id": "92a2f9ee979f8371",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Set Bedroom TRV Temp",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "set_temperature",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1010,
        "y": 620,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "climate.set_temperature",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{ \"temperature\": msg.payload.rooms.bbls.trv_temp }",
        "dataType": "jsonata",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "climate",
        "entityId": [
            "climate.bbls_trv"
        ],
        "floorId": [
        ],
        "id": "b611bd668b366811",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Set Bbls TRV Temp",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "set_temperature",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 990,
        "y": 820,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "switch.turn_on",
        "areaId": [
        ],
        "blockInputOverrides": true,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "switch",
        "entityId": [
            "switch.kitchen_centrala"
        ],
        "floorId": [
        ],
        "id": "608a3bdce2f1443d",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Centrala Turn On ",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_on",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1290,
        "y": 920,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "switch.turn_off",
        "areaId": [
        ],
        "blockInputOverrides": true,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "switch",
        "entityId": [
            "switch.kitchen_centrala"
        ],
        "floorId": [
        ],
        "id": "91eae303da42b93b",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Centrala Turn Off",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_off",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1290,
        "y": 1000,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "checkall": "true",
        "id": "73a4b241abf41aa6",
        "name": "Centrala On/Off",
        "outputs": 2,
        "property": "payload.heat_needed",
        "propertyType": "msg",
        "repair": false,
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "type": "switch",
        "wires": [
            [
                "608a3bdce2f1443d"
            ],
            [
                "91eae303da42b93b"
            ]
        ],
        "x": 980,
        "y": 960,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "checkall": "false",
        "id": "344efd0e6c1bb913",
        "name": "Heat Req By Living",
        "outputs": 2,
        "property": "payload.rooms.living.heater_needed",
        "propertyType": "msg",
        "repair": false,
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "type": "switch",
        "wires": [
            [
                "30cd65a3d52bc93f"
            ],
            [
                "27d03ee096fa5e87"
            ]
        ],
        "x": 990,
        "y": 380,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "input_boolean.turn_on",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "input_boolean",
        "entityId": [
            "input_boolean.living_heater_needed"
        ],
        "floorId": [
        ],
        "id": "30cd65a3d52bc93f",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Enable Heat Req By Living",
        "outputProperties": [
            {
                "property": "temp",
                "propertyType": "msg",
                "value": "payload.rooms.living.current_temp",
                "valueType": "msg"
            },
            {
                "property": "mode",
                "propertyType": "msg",
                "value": "heat",
                "valueType": "str"
            },
            {
                "property": "set",
                "propertyType": "msg",
                "value": "35",
                "valueType": "str"
            }
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_on",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
                "3b90ce858cc14c4d"
            ]
        ],
        "x": 1320,
        "y": 340,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "input_boolean.turn_off",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "input_boolean",
        "entityId": [
            "input_boolean.living_heater_needed"
        ],
        "floorId": [
        ],
        "id": "27d03ee096fa5e87",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Disable Heat Req By Living",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_off",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
                "d2807b0706991fd3"
            ]
        ],
        "x": 1320,
        "y": 420,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "checkall": "false",
        "id": "6eb622bb76a3546a",
        "name": "Heat Req By Bedroom",
        "outputs": 2,
        "property": "payload.rooms.bedroom.heater_needed",
        "propertyType": "msg",
        "repair": false,
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "type": "switch",
        "wires": [
            [
                "7083cea855dfbf51"
            ],
            [
                "e6ce8ef0345d4f21"
            ]
        ],
        "x": 1000,
        "y": 560,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "input_boolean.turn_on",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "input_boolean",
        "entityId": [
            "input_boolean.bedroom_heater_needed"
        ],
        "floorId": [
        ],
        "id": "7083cea855dfbf51",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Enable Heat Req By Bedroom",
        "outputProperties": [
            {
                "property": "template",
                "propertyType": "msg",
                "value": "payload.rooms.bedroom.current_temp",
                "valueType": "msg"
            },
            {
                "property": "mode",
                "propertyType": "msg",
                "value": "heat",
                "valueType": "str"
            },
            {
                "property": "set",
                "propertyType": "msg",
                "value": "30",
                "valueType": "str"
            }
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_on",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1330,
        "y": 520,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "input_boolean.turn_off",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "input_boolean",
        "entityId": [
            "input_boolean.bedroom_heater_needed"
        ],
        "floorId": [
        ],
        "id": "e6ce8ef0345d4f21",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Disable Heat Req By Bedroom",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_off",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1330,
        "y": 600,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "checkall": "false",
        "id": "d8f1651173e7a55b",
        "name": "Heat Req By Bbls",
        "outputs": 2,
        "property": "payload.rooms.bbls.heater_needed",
        "propertyType": "msg",
        "repair": false,
        "rules": [
            {
                "t": "true"
            },
            {
                "t": "false"
            }
        ],
        "type": "switch",
        "wires": [
            [
                "50487b022973cb3f"
            ],
            [
                "4a612f1706263fe1"
            ]
        ],
        "x": 990,
        "y": 760,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "input_boolean.turn_on",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "input_boolean",
        "entityId": [
            "input_boolean.bbls_heater_needed"
        ],
        "floorId": [
        ],
        "id": "50487b022973cb3f",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Enable Heat Req By Bbls",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_on",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1310,
        "y": 720,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "input_boolean.turn_off",
        "areaId": [
        ],
        "blockInputOverrides": false,
        "data": "{}",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "input_boolean",
        "entityId": [
            "input_boolean.bbls_heater_needed"
        ],
        "floorId": [
        ],
        "id": "4a612f1706263fe1",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Disable Heat Req By Bbls",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_off",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1310,
        "y": 800,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "climate.turn_on",
        "areaId": [
        ],
        "blockInputOverrides": true,
        "data": "",
        "dataType": "json",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "climate",
        "entityId": [
            "climate.living_acunit_mqtt_hvac"
        ],
        "floorId": [
        ],
        "id": "3b90ce858cc14c4d",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Start Living Ac",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_on",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1660,
        "y": 340,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "action": "climate.turn_off",
        "areaId": [
        ],
        "blockInputOverrides": true,
        "data": "",
        "dataType": "jsonata",
        "debugenabled": false,
        "deviceId": [
        ],
        "domain": "climate",
        "entityId": [
            "climate.living_acunit_mqtt_hvac"
        ],
        "floorId": [
        ],
        "id": "d2807b0706991fd3",
        "labelId": [
        ],
        "mergeContext": "",
        "mustacheAltTags": false,
        "name": "Stop Living Ac",
        "outputProperties": [
        ],
        "queue": "none",
        "server": "bb9894b2.8b5ad8",
        "service": "turn_off",
        "type": "api-call-service",
        "version": 7,
        "wires": [
            [
            ]
        ],
        "x": 1660,
        "y": 420,
        "z": "6e4b058d9d8e0a83"
    },
    {
        "addon": true,
        "cacheJson": false,
        "connectionDelay": false,
        "enableGlobalContextStore": true,
        "ha_boolean": [
        ],
        "heartbeat": false,
        "heartbeatInterval": "",
        "id": "bb9894b2.8b5ad8",
        "name": "Home Assistant",
        "rejectUnauthorizedCerts": true,
        "statusSeparator": "",
        "type": "server"
    },
    {
        "env": [
        ],
        "id": "9fbbcf4ae31415df",
        "modules": {
            "node-red-contrib-home-assistant-websocket": "0.80.3"
        },
        "type": "global-config"
    }
]
